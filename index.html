<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Cribbage stats</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            --gap: 16px;
            --border: #ddd;
            --muted: #666;
        }

        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            margin: 24px;
        }

        h1 {
            margin: 0 0 8px;
        }

        h2 {
            margin: 24px 0 8px;
        }

        .note {
            color: var(--muted);
            font-size: 13px;
            margin-bottom: 16px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 8px;
        }

        th,
        td {
            border: 1px solid var(--border);
            padding: 8px 10px;
            text-align: right;
        }

        th:first-child,
        td:first-child {
            text-align: left;
        }

        /* One match per row */
        #matches {
            display: flex;
            flex-direction: column;
            gap: var(--gap);
        }

        .match-card {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            width: 100%;
        }

        .match-title {
            font-weight: 600;
            margin-bottom: 8px;
        }

        .charts {
            display: grid;
            grid-template-columns: repeat(2, minmax(240px, 1fr));
            gap: var(--gap);
            align-items: start;
        }

        .chartcol {
            display: flex;
            flex-direction: column;
        }

        .chart-caption {
            text-align: center;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        .chartbox {
            position: relative;
            height: 260px;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px;
        }

        .chartbox canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        .error {
            color: #b00;
            margin-top: 16px;
        }
    </style>
</head>

<body>
    <h1>Cribbage stats</h1>
    <p class="note">Predicted pies show probabilities. Actual pies show game counts. Labels and slices align by index.
    </p>

    <h2>Summary</h2>
    <table id="summary">
        <thead>
            <tr>
                <th>Player</th>
                <th>Played</th>
                <th>Won</th>
                <th>Win rate</th>
                <th>Estimated Skill</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h2>Matches</h2>
    <div id="matches"></div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        // ---- Config: filename at repo root ----
        const DATA_PATH = "./20250815-costa_rica_cribbage_analysis.json";

        // ---- Utilities ----
        const percent = x => (x * 100).toFixed(1) + "%";
        const fmtRate = (w, p) => p ? (w / p).toFixed(3) : "0.000";

        async function loadData() {
            const res = await fetch(DATA_PATH, { cache: "no-store" });
            if (!res.ok) throw new Error(`Failed to load ${DATA_PATH} (${res.status})`);
            return res.json();
        }

        // Simple per-chart segment label plugin
        const segmentLabelPlugin = {
            id: "segmentLabelPlugin",
            afterDatasetsDraw(chart, args, opts) {
                const { ctx } = chart;
                const ds = chart.data.datasets[0];
                if (!ds) return;
                const data = ds.data || [];
                const total = data.reduce((a, b) => a + (b ?? 0), 0);

                const meta = chart.getDatasetMeta(0);
                meta.data.forEach((arc, i) => {
                    const v = data[i];
                    if (v == null) return;

                    // Optional thresholds to avoid clutter
                    const frac = total ? v / total : 0;
                    const show = opts?.minFraction ? frac >= opts.minFraction : true;
                    if (!show || v === 0) return;

                    // Position text at mid-radius, mid-angle
                    const props = arc.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], true);
                    const angle = (props.startAngle + props.endAngle) / 2;
                    const r = (props.innerRadius + props.outerRadius) / 2;
                    const x = props.x + Math.cos(angle) * r;
                    const y = props.y + Math.sin(angle) * r;

                    const label = opts?.formatter ? opts.formatter(v, frac, i, chart) : String(v);

                    ctx.save();
                    ctx.fillStyle = "#000";
                    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(label, x, y);
                    ctx.restore();
                });
            }
        };

        function makeDoughnut(canvas, labels, values, tooltipFmt, isPredicted = false) {
            // For predicted: formatter outputs percentages.
            // For actual: outputs raw counts.
            const pluginOpts = isPredicted
                ? { formatter: (v, frac) => percent(frac), minFraction: 0.06 }   // hide tiny slices <6%
                : { formatter: (v) => String(v), minFraction: 0.08 };    // hide tiny slices <8%

            return new Chart(canvas.getContext("2d"), {
                type: "doughnut",
                data: { labels, datasets: [{ data: values }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { position: "bottom" },
                        tooltip: {
                            callbacks: {
                                label: ctx => {
                                    const label = ctx.label || "";
                                    return tooltipFmt(label, ctx.raw, ctx);
                                }
                            }
                        }
                    },
                    cutout: "55%"
                },
                plugins: [{ ...segmentLabelPlugin, ...{ afterDatasetsDraw: segmentLabelPlugin.afterDatasetsDraw } }],
                // Pass options for the plugin via chart.$plugins for simplicity
                // Chart.js doesn't natively pass per-instance options to anonymous plugins,
                // so we attach them to the chart object and read them inside the plugin if needed.
            });
        }

        function buildSummaryTable(data) {
            const tbody = document.querySelector("#summary tbody");
            const players = new Set([
                ...Object.keys(data.played || {}),
                ...Object.keys(data.wins || {}),
                ...Object.keys(data.skills || {})
            ]);

            const rows = [];
            players.forEach(name => {
                const played = data.played?.[name] ?? 0;
                const won = data.wins?.[name] ?? 0;
                const skill = data.skills?.[name];
                rows.push({ name, played, won, winrate: played ? won / played : 0, skill });
            });

            rows.sort((a, b) => a.name.localeCompare(b.name));

            tbody.innerHTML = rows.map(r => `
        <tr>
          <td>${r.name}</td>
          <td>${r.played}</td>
          <td>${r.won}</td>
          <td>${fmtRate(r.won, r.played)}</td>
          <td>${r.skill ?? ""}</td>
        </tr>
      `).join("");
        }

        function buildMatches(data) {
            const root = document.getElementById("matches");
            root.innerHTML = "";

            (data.matches || []).forEach(m => {
                const labels = m.players || m.labels;

                const card = document.createElement("div");
                card.className = "match-card";

                const title = document.createElement("div");
                title.className = "match-title";
                title.textContent = labels.join(" vs ");
                card.appendChild(title);

                const charts = document.createElement("div");
                charts.className = "charts";

                // Column: Predicted
                const predCol = document.createElement("div");
                predCol.className = "chartcol";
                const predCaption = document.createElement("div");
                predCaption.className = "chart-caption";
                predCaption.textContent = "Predicted";
                const predBox = document.createElement("div");
                predBox.className = "chartbox";
                const predCanvas = document.createElement("canvas");
                predBox.appendChild(predCanvas);
                predCol.appendChild(predCaption);
                predCol.appendChild(predBox);
                charts.appendChild(predCol);

                // Column: Actual
                const actCol = document.createElement("div");
                actCol.className = "chartcol";
                const actCaption = document.createElement("div");
                actCaption.className = "chart-caption";
                actCaption.textContent = "Actual";
                const actBox = document.createElement("div");
                actBox.className = "chartbox";
                const actCanvas = document.createElement("canvas");
                actBox.appendChild(actCanvas);
                actCol.appendChild(actCaption);
                actCol.appendChild(actBox);
                charts.appendChild(actCol);

                card.appendChild(charts);
                root.appendChild(card);

                // Predicted data, normalised defensively
                const probs = (m.predicted_win_rates || m.predicted || []).slice();
                const s = probs.reduce((a, b) => a + b, 0);
                const norm = s ? probs.map(x => x / s) : probs;
                const predChart = makeDoughnut(
                    predCanvas, labels, norm,
                    (label, v) => `${label}: ${percent(v)}`,
                    true
                );
                // Attach plugin opts
                predChart.$segmentLabelOpts = { isPredicted: true };

                // Actual
                const actual = m.actual_wins ?? m.actual;
                const hasActual = Array.isArray(actual) && actual.length === labels.length && actual.some(v => v !== null);

                if (hasActual) {
                    const actChart = makeDoughnut(
                        actCanvas,
                        labels,
                        actual.map(v => v ?? 0),
                        (label, v, ctx) => {
                            const total = actual.reduce((a, b) => a + (b ?? 0), 0);
                            const pct = total ? (v / total) : 0;
                            return `${label}: ${v} (${percent(pct)})`;
                        },
                        false
                    );
                    actChart.$segmentLabelOpts = { isPredicted: false };
                } else {
                    actBox.replaceChild(document.createTextNode("No actuals yet"), actCanvas);
                }
            });
        }

        (async function main() {
            const data = await loadData();
            buildSummaryTable(data);
            buildMatches(data);
        })().catch(err => {
            document.body.insertAdjacentHTML("beforeend", `<p class="error">Error: ${err.message}</p>`);
            console.error(err);
        });
    </script>
</body>

</html>